/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.24.2
 * source: protos/tools/action.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./tool";
import * as dependency_2 from "./command";
import * as pb_1 from "google-protobuf";
export namespace zorro {
    export class ActionChild extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2]];
        constructor(data?: any[] | ({
            upstream?: string[];
        } & (({
            command?: dependency_2.zorro.Command;
            action?: never;
        } | {
            command?: never;
            action?: Action;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("command" in data && data.command != undefined) {
                    this.command = data.command;
                }
                if ("action" in data && data.action != undefined) {
                    this.action = data.action;
                }
                if ("upstream" in data && data.upstream != undefined) {
                    this.upstream = data.upstream;
                }
            }
        }
        get command() {
            return pb_1.Message.getWrapperField(this, dependency_2.zorro.Command, 1) as dependency_2.zorro.Command;
        }
        set command(value: dependency_2.zorro.Command) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_command() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get action() {
            return pb_1.Message.getWrapperField(this, Action, 2) as Action;
        }
        set action(value: Action) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_action() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get upstream() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
        }
        set upstream(value: string[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get child() {
            const cases: {
                [index: number]: "none" | "command" | "action";
            } = {
                0: "none",
                1: "command",
                2: "action"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            command?: ReturnType<typeof dependency_2.zorro.Command.prototype.toObject>;
            action?: ReturnType<typeof Action.prototype.toObject>;
            upstream?: string[];
        }): ActionChild {
            const message = new ActionChild({});
            if (data.command != null) {
                message.command = dependency_2.zorro.Command.fromObject(data.command);
            }
            if (data.action != null) {
                message.action = Action.fromObject(data.action);
            }
            if (data.upstream != null) {
                message.upstream = data.upstream;
            }
            return message;
        }
        toObject() {
            const data: {
                command?: ReturnType<typeof dependency_2.zorro.Command.prototype.toObject>;
                action?: ReturnType<typeof Action.prototype.toObject>;
                upstream?: string[];
            } = {};
            if (this.command != null) {
                data.command = this.command.toObject();
            }
            if (this.action != null) {
                data.action = this.action.toObject();
            }
            if (this.upstream != null) {
                data.upstream = this.upstream;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_command)
                writer.writeMessage(1, this.command, () => this.command.serialize(writer));
            if (this.has_action)
                writer.writeMessage(2, this.action, () => this.action.serialize(writer));
            if (this.upstream.length)
                writer.writeRepeatedString(3, this.upstream);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ActionChild {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ActionChild();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.command, () => message.command = dependency_2.zorro.Command.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.action, () => message.action = Action.deserialize(reader));
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ActionChild {
            return ActionChild.deserialize(bytes);
        }
    }
    export class Action extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            base?: dependency_1.zorro.ToolBase;
            children?: Map<string, ActionChild>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("base" in data && data.base != undefined) {
                    this.base = data.base;
                }
                if ("children" in data && data.children != undefined) {
                    this.children = data.children;
                }
            }
            if (!this.children)
                this.children = new Map();
        }
        get base() {
            return pb_1.Message.getWrapperField(this, dependency_1.zorro.ToolBase, 1) as dependency_1.zorro.ToolBase;
        }
        set base(value: dependency_1.zorro.ToolBase) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_base() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get children() {
            return pb_1.Message.getField(this, 2) as any as Map<string, ActionChild>;
        }
        set children(value: Map<string, ActionChild>) {
            pb_1.Message.setField(this, 2, value as any);
        }
        static fromObject(data: {
            base?: ReturnType<typeof dependency_1.zorro.ToolBase.prototype.toObject>;
            children?: {
                [key: string]: ReturnType<typeof ActionChild.prototype.toObject>;
            };
        }): Action {
            const message = new Action({});
            if (data.base != null) {
                message.base = dependency_1.zorro.ToolBase.fromObject(data.base);
            }
            if (typeof data.children == "object") {
                message.children = new Map(Object.entries(data.children).map(([key, value]) => [key, ActionChild.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                base?: ReturnType<typeof dependency_1.zorro.ToolBase.prototype.toObject>;
                children?: {
                    [key: string]: ReturnType<typeof ActionChild.prototype.toObject>;
                };
            } = {};
            if (this.base != null) {
                data.base = this.base.toObject();
            }
            if (this.children != null) {
                data.children = (Object.fromEntries)((Array.from)(this.children).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_base)
                writer.writeMessage(1, this.base, () => this.base.serialize(writer));
            for (const [key, value] of this.children) {
                writer.writeMessage(2, this.children, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Action {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Action();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.base, () => message.base = dependency_1.zorro.ToolBase.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.children as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = ActionChild.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Action {
            return Action.deserialize(bytes);
        }
    }
}
